"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[540],{4611:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=r(4848),s=r(8453);const a={},o="SQL++ (formerly N1QL) Queries",i={id:"tutorial-ruby-couchbase-orm/sqlpp-queries",title:"SQL++ (formerly N1QL) Queries",description:"CouchbaseOrm provides support for executing SQL++ queries directly from your Ruby code. SQL++ (or formerly N1QL,i.e. Non-First Normal Form Query Language) is a powerful query language that allows you to perform complex queries and aggregations on your Couchbase data.",source:"@site/docs/tutorial-ruby-couchbase-orm/07-sqlpp-queries.md",sourceDirName:"tutorial-ruby-couchbase-orm",slug:"/tutorial-ruby-couchbase-orm/sqlpp-queries",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/sqlpp-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/couchbase-examples/ruby-couchbase-orm-quickstart/tree/docs/docusaurus/docusaurus/docs/docs/tutorial-ruby-couchbase-orm/07-sqlpp-queries.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Associations and Validations",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/associations-and-validations"},next:{title:"Views (aka Map/Reduce indexes)",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/views"}},u={},c=[{value:"7.1 Defining SQL++ Queries",id:"71-defining-sql-queries",level:2},{value:"7.2 Query Parameters",id:"72-query-parameters",level:2},{value:"7.3 Executing SQL++ Queries",id:"73-executing-sql-queries",level:2},{value:"7.4 Query Options",id:"74-query-options",level:2},{value:"7.5 Placeholder Values",id:"75-placeholder-values",level:2},{value:"7.6 Query Result Processing",id:"76-query-result-processing",level:2},{value:"7.7 Indexing for SQL++",id:"77-indexing-for-sql",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"sql-formerly-n1ql-queries",children:"SQL++ (formerly N1QL) Queries"}),"\n",(0,t.jsx)(n.p,{children:"CouchbaseOrm provides support for executing SQL++ queries directly from your Ruby code. SQL++ (or formerly N1QL,i.e. Non-First Normal Form Query Language) is a powerful query language that allows you to perform complex queries and aggregations on your Couchbase data."}),"\n",(0,t.jsx)(n.h2,{id:"71-defining-sql-queries",children:"7.1 Defining SQL++ Queries"}),"\n",(0,t.jsxs)(n.p,{children:["To define an SQL++ query in your model, you can use the ",(0,t.jsx)(n.code,{children:"n1ql"})," macro provided by CouchbaseOrm. Here are a few examples:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class N1QLTest < CouchbaseOrm::Base\n  attribute :name, type: String\n  attribute :lastname, type: String\n  enum rating: %i[awesome good okay bad], default: :okay\n  attribute :country, type: String\n\n  # Example 1: Custom query with specific rating values\n  n1ql :by_custom_rating, emit_key: [:rating], query_fn: proc { |bucket, _values, options|\n    cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND rating IN [1, 2] ORDER BY name ASC\", options)\n  }\n\n  # Example 2: Simple query by name\n  n1ql :by_name, emit_key: [:name]\n\n  # Example 3: Simple query by lastname\n  n1ql :by_lastname, emit_key: [:lastname]\n\n  # Example 4: Custom query by country with parameter binding\n  n1ql :by_country, emit_key: [:country], query_fn: proc { |bucket, values, options|\n    cluster.query(\n      \"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND country = $country ORDER BY name ASC\",\n      Couchbase::Options::Query(named_parameters: { country: values[0] })\n    )\n  }\n\n  # Example 5: Simple query by rating\n  n1ql :by_rating_emit, emit_key: :rating\n\n  # Example 6: Custom query by rating with parameter binding\n  n1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n    cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n  }\n\n  # Example 7: Custom query by rating with custom ordering\n  n1ql :by_rating_reverse, emit_key: :rating, custom_order: 'name DESC'\n\n  # Example 8: Simple query by rating without including documents\n  n1ql :by_rating_without_docs, emit_key: :rating, include_docs: false\n\n  # Index definition for the rating attribute\n  index_n1ql :rating\nend\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"In these examples:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"by_custom_rating"})," query selects the document IDs where the type is 'n1_ql_test' and the rating is either 1 or 2, ordered by the name attribute in ascending order."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"by_name"}),", ",(0,t.jsx)(n.code,{children:"by_lastname"}),", and ",(0,t.jsx)(n.code,{children:"by_rating_emit"})," queries use the emit_key option to specify the attribute to be used as the key for the query."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"by_custom_rating_values"})," query demonstrates passing values to the query using placeholders ($1, $2, etc.) and the quote method to properly escape the values."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"by_rating_reverse"})," query uses the custom_order option to specify a custom ordering for the query results."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"by_rating_without_docs"})," query sets include_docs to false to retrieve only the document IDs without fetching the full documents."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"index_n1ql"})," macro is used to define an index on the rating attribute and generate a corresponding query method. Note that the index_n1ql macro does not create the index in the Couchbase Dashboard directly; you would need to create the index separately using the Couchbase Dashboard or the Couchbase Query UI."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"72-query-parameters",children:"7.2 Query Parameters"}),"\n",(0,t.jsx)(n.p,{children:"SQL++ queries often require parameters to be passed in order to filter or customize the results. CouchbaseOrm allows you to define queries with placeholders and provide the parameter values when executing the query."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"n1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"values"})," parameter represents an array of values passed to the query. The ",(0,t.jsx)(n.code,{children:"quote"})," method is used to properly escape and format the values for use in the query."]}),"\n",(0,t.jsx)(n.h2,{id:"73-executing-sql-queries",children:"7.3 Executing SQL++ Queries"}),"\n",(0,t.jsx)(n.p,{children:"To execute an SQL++ query, you simply call the defined query method on your model class."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"docs = N1QLTest.by_custom_rating().collect { |ob| ob.name }\n"})}),"\n",(0,t.jsx)(n.p,{children:"CouchbaseOrm automatically executes the SQL++ query and returns the result set, which you can then process as needed."}),"\n",(0,t.jsx)(n.h2,{id:"74-query-options",children:"7.4 Query Options"}),"\n",(0,t.jsx)(n.p,{children:"CouchbaseOrm provides various options to customize the execution of SQL++ queries. These options can be passed as a hash parameter to the query method."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"docs = N1QLTest.by_rating_reverse(key: 1)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"75-placeholder-values",children:"7.5 Placeholder Values"}),"\n",(0,t.jsx)(n.p,{children:"You can use placeholder values in your SQL++ queries and pass the actual values when executing the query."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:" n1ql :by_country, emit_key: [:country], query_fn: proc { |bucket, values, options|\n    cluster.query(\n      \"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND country = $country ORDER BY name ASC\",\n      Couchbase::Options::Query(named_parameters: { country: values[0] })\n    )\n  }\n\ndocs = N1QLTest.by_country(key: 'USA').collect { |ob| ob.name }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"by_country"})," query uses a placeholder ",(0,t.jsx)(n.code,{children:"$country"})," in the query string and passes the actual value ",(0,t.jsx)(n.code,{children:"'USA'"})," as the parameter value when executing the query."]}),"\n",(0,t.jsx)(n.h2,{id:"76-query-result-processing",children:"7.6 Query Result Processing"}),"\n",(0,t.jsx)(n.p,{children:"By default, CouchbaseOrm automatically maps the query result to instances of your model class. However, you can also process the query result manually if needed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"n1ql :by_custom_rating, emit_key: [:rating], query_fn: proc { |bucket, _values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND rating IN [1, 2] ORDER BY name ASC\", options)\n}\n\nn1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, the ",(0,t.jsx)(n.code,{children:"by_custom_rating"})," and ",(0,t.jsx)(n.code,{children:"by_custom_rating_values"})," queries are executed, and the results are processed manually to extract the ",(0,t.jsx)(n.code,{children:"name"})," attribute from each document."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"# Query by custom rating\ndocs = N1QLTest.by_custom_rating.collect { |ob| ob.name }\n\n# Query by custom rating values\ndocs = N1QLTest.by_custom_rating_values(key: [[1, 2]]).collect { |ob| ob.name }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above examples, the ",(0,t.jsx)(n.code,{children:"collect"})," method is used to extract the ",(0,t.jsx)(n.code,{children:"name"})," attribute from each document in the result set."]}),"\n",(0,t.jsx)(n.h2,{id:"77-indexing-for-sql",children:"7.7 Indexing for SQL++"}),"\n",(0,t.jsx)(n.p,{children:"To optimize the performance of SQL++ queries, it's important to create appropriate indexes on the fields used in the query conditions. Couchbase Server provides a way to create indexes using the Index service."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass N1QLTest < CouchbaseOrm::Base\n  ... \n\n  # Index definition for the rating attribute\n  index_n1ql :rating\nend\n\n# Query using index_n1ql\ndocs = N1QLTest.find_by_rating(2).collect { |ob| ob.name }\n\n# Query using index_n1ql\ndocs = N1QLTest.by_rating.to_a.collect { |ob| ob.name }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, indexes are defined on the ",(0,t.jsx)(n.code,{children:"rating"})," attribute using the ",(0,t.jsx)(n.code,{children:"index_n1ql"})," macro."]}),"\n",(0,t.jsx)(n.p,{children:"Indexing helps improve the efficiency of SQL++ queries by allowing Couchbase Server to quickly locate the relevant documents based on the indexed fields."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"SQL++ queries in CouchbaseOrm provide a powerful and flexible way to retrieve data from Couchbase Server. By leveraging the expressive power of SQL++, you can perform complex queries, aggregations, and data manipulations directly from your Ruby code."}),"\n",(0,t.jsx)(n.p,{children:"Remember to ensure that you have the necessary indexes created on the fields used in your queries for optimal performance. Additionally, consider the query consistency level and other options based on your application's requirements."}),"\n",(0,t.jsx)(n.p,{children:"With CouchbaseOrm's SQL++ support, you can easily integrate advanced querying capabilities into your Ruby application, enabling you to retrieve and manipulate data stored in Couchbase Server efficiently."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);