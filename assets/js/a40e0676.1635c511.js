"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[540],{273:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=r(4848),t=r(8453);const o={},i="SQL++ (formerly N1QL) Queries",a={id:"tutorial-ruby-couchbase-orm/sqlpp-queries",title:"SQL++ (formerly N1QL) Queries",description:"CouchbaseOrm provides support for executing SQL++ queries directly from your Ruby code. SQL++ (or formerly N1QL,i.e. Non-First Normal Form Query Language) is a powerful query language that allows you to perform complex queries and aggregations on your Couchbase data.",source:"@site/docs/tutorial-ruby-couchbase-orm/07-sqlpp-queries.md",sourceDirName:"tutorial-ruby-couchbase-orm",slug:"/tutorial-ruby-couchbase-orm/sqlpp-queries",permalink:"/docs/tutorial-ruby-couchbase-orm/sqlpp-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/couchbase-examples/ruby-couchbase-orm-quickstart/tree/docs/docusaurus/docusaurus/docs/docs/tutorial-ruby-couchbase-orm/07-sqlpp-queries.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Associations and Validations",permalink:"/docs/tutorial-ruby-couchbase-orm/associations-and-validations"},next:{title:"Views (aka Map/Reduce indexes)",permalink:"/docs/tutorial-ruby-couchbase-orm/views"}},c={},l=[{value:"Defining SQL++ Queries",id:"defining-sql-queries",level:2},{value:"Query Parameters",id:"query-parameters",level:2},{value:"Executing SQL++ Queries",id:"executing-sql-queries",level:2},{value:"Query Options",id:"query-options",level:2},{value:"Placeholder Values",id:"placeholder-values",level:2},{value:"Query Result Processing",id:"query-result-processing",level:2},{value:"Indexing for SQL++",id:"indexing-for-sql",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"sql-formerly-n1ql-queries",children:"SQL++ (formerly N1QL) Queries"}),"\n",(0,s.jsx)(n.p,{children:"CouchbaseOrm provides support for executing SQL++ queries directly from your Ruby code. SQL++ (or formerly N1QL,i.e. Non-First Normal Form Query Language) is a powerful query language that allows you to perform complex queries and aggregations on your Couchbase data."}),"\n",(0,s.jsx)(n.h2,{id:"defining-sql-queries",children:"Defining SQL++ Queries"}),"\n",(0,s.jsxs)(n.p,{children:["To define an SQL++ query in your model, you can use the ",(0,s.jsx)(n.code,{children:"n1ql"})," macro provided by CouchbaseOrm. Here are a few examples:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"class N1QLTest < CouchbaseOrm::Base\n  attribute :name, type: String\n  attribute :lastname, type: String\n  enum rating: %i[awesome good okay bad], default: :okay\n\n  n1ql :by_custom_rating, emit_key: [:rating], query_fn: proc { |bucket, _values, options|\n    cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND rating IN [1, 2] ORDER BY name ASC\", options)\n  }\n\n  n1ql :by_name, emit_key: [:name]\n\n  n1ql :by_lastname, emit_key: [:lastname]\n\n  n1ql :by_rating_emit, emit_key: :rating\n\n  n1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n}\n  n1ql :by_rating_reverse, emit_key: :rating, custom_order: 'name DESC'\n\n  n1ql :by_rating_without_docs, emit_key: :rating, include_docs: false\n\n  index_n1ql :rating\nend\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"In these examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"by_custom_rating"})," query selects the document IDs where the ",(0,s.jsx)(n.code,{children:"type"})," is ",(0,s.jsx)(n.code,{children:"'n1_ql_test'"})," and the ",(0,s.jsx)(n.code,{children:"rating"})," is either 1 or 2, ordered by the ",(0,s.jsx)(n.code,{children:"name"})," attribute in ascending order."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"by_name"}),", ",(0,s.jsx)(n.code,{children:"by_lastname"}),", and ",(0,s.jsx)(n.code,{children:"by_rating_emit"})," queries use the ",(0,s.jsx)(n.code,{children:"emit_key"})," option to specify the attribute to be used as the key for the query."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"by_custom_rating_values"})," query demonstrates passing values to the query using placeholders (",(0,s.jsx)(n.code,{children:"$1"}),", ",(0,s.jsx)(n.code,{children:"$2"}),", etc.) and the ",(0,s.jsx)(n.code,{children:"quote"})," method to properly escape the values."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"by_rating_reverse"})," query uses the ",(0,s.jsx)(n.code,{children:"custom_order"})," option to specify a custom ordering for the query results."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"by_rating_without_docs"})," query sets ",(0,s.jsx)(n.code,{children:"include_docs"})," to ",(0,s.jsx)(n.code,{children:"false"})," to retrieve only the document IDs without fetching the full documents."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"index_n1ql"})," macro is used to define an index on the ",(0,s.jsx)(n.code,{children:"rating"})," attribute and generate a corresponding query method."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-parameters",children:"Query Parameters"}),"\n",(0,s.jsx)(n.p,{children:"SQL++ queries often require parameters to be passed in order to filter or customize the results. CouchbaseOrm allows you to define queries with placeholders and provide the parameter values when executing the query."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"n1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"values"})," parameter represents an array of values passed to the query. The ",(0,s.jsx)(n.code,{children:"quote"})," method is used to properly escape and format the values for use in the query."]}),"\n",(0,s.jsx)(n.h2,{id:"executing-sql-queries",children:"Executing SQL++ Queries"}),"\n",(0,s.jsx)(n.p,{children:"To execute an SQL++ query, you simply call the defined query method on your model class."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"docs = N1QLTest.by_custom_rating().collect { |ob| ob.name }\n"})}),"\n",(0,s.jsx)(n.p,{children:"CouchbaseOrm automatically executes the SQL++ query and returns the result set, which you can then process as needed."}),"\n",(0,s.jsx)(n.h2,{id:"query-options",children:"Query Options"}),"\n",(0,s.jsx)(n.p,{children:"CouchbaseOrm provides various options to customize the execution of SQL++ queries. These options can be passed as a hash parameter to the query method."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"docs = N1QLTest.by_rating_reverse(key: 1)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"placeholder-values",children:"Placeholder Values"}),"\n",(0,s.jsxs)(n.p,{children:["In addition to using positional placeholders (",(0,s.jsx)(n.code,{children:"$1"}),", ",(0,s.jsx)(n.code,{children:"$2"}),", etc.), CouchbaseOrm also supports named placeholders for better readability."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"n1ql :by_name_and_rating, \"SELECT * FROM `#{bucket.name}` WHERE name = $name AND rating = $rating\"\n\ndocs = N1QLTest.by_name_and_rating(name: 'John', rating: 'awesome')\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"$name"})," and ",(0,s.jsx)(n.code,{children:"$rating"})," placeholders are used in the query, and the values are provided using a hash parameter with the corresponding keys."]}),"\n",(0,s.jsx)(n.h2,{id:"query-result-processing",children:"Query Result Processing"}),"\n",(0,s.jsx)(n.p,{children:"By default, CouchbaseOrm automatically maps the query result to instances of your model class. However, you can also process the query result manually if needed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"n1ql :by_custom_rating, emit_key: [:rating], query_fn: proc { |bucket, _values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` WHERE type = 'n1_ql_test' AND rating IN [1, 2] ORDER BY name ASC\", options)\n}\n\nn1ql :by_custom_rating_values, emit_key: [:rating], query_fn: proc { |bucket, values, options|\n  cluster.query(\"SELECT raw meta().id FROM `#{bucket.name}` where type = 'n1_ql_test' AND rating IN #{quote(values[0])} ORDER BY name ASC\", options)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, the ",(0,s.jsx)(n.code,{children:"by_custom_rating"})," and ",(0,s.jsx)(n.code,{children:"by_custom_rating_values"})," queries are executed, and the results are processed manually to extract the ",(0,s.jsx)(n.code,{children:"name"})," attribute from each document."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# Query by custom rating\ndocs = N1QLTest.by_custom_rating.collect { |ob| ob.name }\n\n# Query by custom rating values\ndocs = N1QLTest.by_custom_rating_values(key: [[1, 2]]).collect { |ob| ob.name }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the above examples, the ",(0,s.jsx)(n.code,{children:"collect"})," method is used to extract the ",(0,s.jsx)(n.code,{children:"name"})," attribute from each document in the result set."]}),"\n",(0,s.jsx)(n.h2,{id:"indexing-for-sql",children:"Indexing for SQL++"}),"\n",(0,s.jsx)(n.p,{children:"To optimize the performance of SQL++ queries, it's important to create appropriate indexes on the fields used in the query conditions. Couchbase Server provides a way to create indexes using the Index service."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# Query using index_n1ql\ndocs = N1QLTest.find_by_rating(2).collect { |ob| ob.name }\n\n# Query using index_n1ql\ndocs = N1QLTest.by_rating.to_a.collect { |ob| ob.name }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, indexes are defined on the ",(0,s.jsx)(n.code,{children:"rating"})," attribute using the ",(0,s.jsx)(n.code,{children:"index_n1ql"})," macro."]}),"\n",(0,s.jsx)(n.p,{children:"Indexing helps improve the efficiency of SQL++ queries by allowing Couchbase Server to quickly locate the relevant documents based on the indexed fields."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"SQL++ queries in CouchbaseOrm provide a powerful and flexible way to retrieve data from Couchbase Server. By leveraging the expressive power of SQL++, you can perform complex queries, aggregations, and data manipulations directly from your Ruby code."}),"\n",(0,s.jsx)(n.p,{children:"Remember to ensure that you have the necessary indexes created on the fields used in your queries for optimal performance. Additionally, consider the query consistency level and other options based on your application's requirements."}),"\n",(0,s.jsx)(n.p,{children:"With CouchbaseOrm's SQL++ support, you can easily integrate advanced querying capabilities into your Ruby application, enabling you to retrieve and manipulate data stored in Couchbase Server efficiently."})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var s=r(6540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);