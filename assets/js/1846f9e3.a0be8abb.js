"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7341],{2770:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var r=n(4848),t=n(8453);const a={sidebar_position:5},i="Persistence",o={id:"tutorial-ruby-couchbase-orm/persistence",title:"Persistence",description:"CouchbaseOrm provides a simple and intuitive way to persist data to Couchbase Server. With CouchbaseOrm, you can easily create, update, save, and destroy records using a set of built-in methods.",source:"@site/docs/tutorial-ruby-couchbase-orm/05-persistence.md",sourceDirName:"tutorial-ruby-couchbase-orm",slug:"/tutorial-ruby-couchbase-orm/persistence",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/persistence",draft:!1,unlisted:!1,editUrl:"https://github.com/couchbase-examples/ruby-couchbase-orm-quickstart/tree/docs/docusaurus/docusaurus/docs/docs/tutorial-ruby-couchbase-orm/05-persistence.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Querying",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/querying"},next:{title:"Associations and Validations",permalink:"/ruby-couchbase-orm-quickstart/docs/tutorial-ruby-couchbase-orm/associations-and-validations"}},c={},d=[{value:"5.1. Creating Records",id:"51-creating-records",level:2},{value:"5.2. Updating Records",id:"52-updating-records",level:2},{value:"5.3. Saving Records",id:"53-saving-records",level:2},{value:"5.4. Destroying Records",id:"54-destroying-records",level:2},{value:"5.5. Updating Specific Fields",id:"55-updating-specific-fields",level:2},{value:"5.6. Atomic Operations",id:"56-atomic-operations",level:2},{value:"5.7. Callbacks",id:"57-callbacks",level:2},{value:"5.8. Transactions",id:"58-transactions",level:2}];function l(e){const s={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"persistence",children:"Persistence"}),"\n",(0,r.jsx)(s.p,{children:"CouchbaseOrm provides a simple and intuitive way to persist data to Couchbase Server. With CouchbaseOrm, you can easily create, update, save, and destroy records using a set of built-in methods."}),"\n",(0,r.jsx)(s.h2,{id:"51-creating-records",children:"5.1. Creating Records"}),"\n",(0,r.jsxs)(s.p,{children:["To create a new record, you can instantiate a new instance of your model class and then call the ",(0,r.jsx)(s.code,{children:"save"})," method to persist it to the database."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.new(name: 'John', email: 'john@example.com')\nuser.save\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Alternatively, you can use the ",(0,r.jsx)(s.code,{children:"create"})," method to create a new record in a single step:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.create(name: 'John', email: 'john@example.com')\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"create"})," method instantiates a new instance of the model, sets the attributes, and saves it to the database."]}),"\n",(0,r.jsx)(s.h2,{id:"52-updating-records",children:"5.2. Updating Records"}),"\n",(0,r.jsxs)(s.p,{children:["To update an existing record, you can modify its attributes and then call the ",(0,r.jsx)(s.code,{children:"save"})," method to persist the changes."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.find('user_id_123')\nuser.name = 'John Doe'\nuser.save\n"})}),"\n",(0,r.jsx)(s.p,{children:"CouchbaseOrm automatically tracks the changes made to the attributes and updates only the modified fields in the database."}),"\n",(0,r.jsx)(s.h2,{id:"53-saving-records",children:"5.3. Saving Records"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"save"})," method is used to persist a record to the database, whether it's a new record or an existing one with modifications."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.new(name: 'John')\nuser.save # Creates a new record\n\nuser.name = 'John Doe'\nuser.save # Updates the existing record\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If the record is new (i.e., it doesn't have an ID), ",(0,r.jsx)(s.code,{children:"save"})," will create a new document in Couchbase Server. If the record already exists, ",(0,r.jsx)(s.code,{children:"save"})," will update the existing document with the modified attributes."]}),"\n",(0,r.jsx)(s.h2,{id:"54-destroying-records",children:"5.4. Destroying Records"}),"\n",(0,r.jsxs)(s.p,{children:["To delete a record from the database, you can call the ",(0,r.jsx)(s.code,{children:"destroy"})," method on an instance of your model."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.find('user_id_123')\nuser.destroy\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"destroy"})," method removes the corresponding document from Couchbase Server and freezes the model instance to prevent further modifications."]}),"\n",(0,r.jsx)(s.h2,{id:"55-updating-specific-fields",children:"5.5. Updating Specific Fields"}),"\n",(0,r.jsx)(s.p,{children:"CouchbaseOrm provides a way to update specific fields of a record without retrieving the entire document from the database. This can be useful for performance optimization when you only need to update a subset of attributes."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.find('user_id_123')\nuser.update(name: 'John Doe', age: 30)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"update"})," method updates only the specified attributes of the record in the database."]}),"\n",(0,r.jsx)(s.h2,{id:"56-atomic-operations",children:"5.6. Atomic Operations"}),"\n",(0,r.jsx)(s.p,{children:"CouchbaseOrm supports atomic operations, which allow you to perform certain database operations in a single, indivisible step. Atomic operations ensure data consistency and help avoid race conditions in concurrent environments."}),"\n",(0,r.jsx)(s.p,{children:"Some common atomic operations include:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"increment"}),": Atomically increments a numeric attribute by a specified value."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"decrement"}),": Atomically decrements a numeric attribute by a specified value."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"append"}),": Atomically appends a value to a string attribute."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"prepend"}),": Atomically prepends a value to a string attribute."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"touch"}),": Updates the document's expiration time without modifying its content."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Here's an example of using atomic operations:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"user = User.find('user_id_123')\nuser.increment(:login_count)\nuser.touch(expiry: 1.hour.from_now)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["In this example, the ",(0,r.jsx)(s.code,{children:"increment"})," operation atomically increments the ",(0,r.jsx)(s.code,{children:"login_count"})," attribute of the user, and the ",(0,r.jsx)(s.code,{children:"touch"})," operation updates the document's expiration time to one hour from now."]}),"\n",(0,r.jsx)(s.h2,{id:"57-callbacks",children:"5.7. Callbacks"}),"\n",(0,r.jsx)(s.p,{children:"As mentioned in the previous section on defining models, CouchbaseOrm supports lifecycle callbacks that allow you to execute code at certain points in a record's persistence lifecycle."}),"\n",(0,r.jsxs)(s.p,{children:["Callbacks can be used to perform actions before or after specific events, such as saving or updating a record. Some commonly used callbacks include ",(0,r.jsx)(s.code,{children:"before_save"}),", ",(0,r.jsx)(s.code,{children:"after_save"}),", ",(0,r.jsx)(s.code,{children:"before_create"}),", ",(0,r.jsx)(s.code,{children:"after_create"}),", ",(0,r.jsx)(s.code,{children:"before_update"}),", ",(0,r.jsx)(s.code,{children:"after_update"}),", ",(0,r.jsx)(s.code,{children:"before_destroy"}),", and ",(0,r.jsx)(s.code,{children:"after_destroy"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"class User < CouchbaseOrm::Base\n  before_save :encrypt_password\n  after_create :send_welcome_email\n\n  private\n\n  def encrypt_password\n    self.password = encrypt(password) if password_changed?\n  end\n\n  def send_welcome_email\n    UserMailer.welcome_email(self).deliver_now\n  end\nend\n"})}),"\n",(0,r.jsxs)(s.p,{children:["In this example, the ",(0,r.jsx)(s.code,{children:"encrypt_password"})," callback is executed before saving a user record, encrypting the password if it has been changed. The ",(0,r.jsx)(s.code,{children:"send_welcome_email"})," callback is executed after creating a new user record, sending a welcome email to the user."]}),"\n",(0,r.jsx)(s.p,{children:"Callbacks provide a way to encapsulate and reuse common logic related to the persistence lifecycle of your records."}),"\n",(0,r.jsx)(s.h2,{id:"58-transactions",children:"5.8. Transactions"}),"\n",(0,r.jsx)(s.p,{children:"CouchbaseOrm supports transactions, which allow you to group multiple database operations into a single, atomic unit of work. Transactions ensure that all the operations within the transaction either succeed together or fail together, maintaining data integrity."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ruby",children:"CouchbaseOrm.transaction do\n  user = User.create(name: 'John')\n  account = Account.create(user: user, balance: 100)\n  # ...\nend\n"})}),"\n",(0,r.jsx)(s.p,{children:"In this example, the creation of a user and an associated account are wrapped inside a transaction. If any operation within the transaction fails, all the changes made within the transaction will be rolled back, ensuring that the database remains in a consistent state."}),"\n",(0,r.jsx)(s.p,{children:"Transactions are useful when you need to perform multiple related operations that should succeed or fail together, such as creating related records or updating multiple documents atomically."}),"\n",(0,r.jsx)(s.p,{children:"That covers the basics of persistence with CouchbaseOrm. With these methods and features, you can easily create, update, delete, and manipulate records in Couchbase Server using a simple and expressive API."}),"\n",(0,r.jsx)(s.p,{children:"In the next section, we'll explore the powerful associations feature of CouchbaseOrm, which allows you to define and work with relationships between your models."})]})}function u(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var r=n(6540);const t={},a=r.createContext(t);function i(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);